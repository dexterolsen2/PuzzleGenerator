<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Word Search PDF Generator</title>
        <!-- 1. Tailwind CSS for styling -->
        <script src="https://cdn.tailwindcss.com"></script>
        <!-- 2. jsPDF library for creating the PDF -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
        <!-- 3. Inter font family -->
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
            rel="stylesheet"
        />
        <style>
            body {
                font-family: "Inter", sans-serif;
            }
            /* Custom style for number input arrows */
            input[type="number"]::-webkit-inner-spin-button,
            input[type="number"]::-webkit-outer-spin-button {
                -webkit-appearance: auto;
                opacity: 1;
                margin-left: 5px;
            }
        </style>
    </head>
    <body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">
        <div class="bg-white p-8 rounded-lg shadow-xl max-w-lg w-full">
            <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">
                Word Search PDF Generator
            </h1>

            <p class="text-gray-600 mb-6 text-center">
                Choose how many puzzles you'd like to create for each size. (Max
                100 total).
            </p>

            <!-- Input Section -->
            <div class="space-y-4">
                <!-- 20x20 Input -->
                <div class="flex items-center justify-between">
                    <label
                        for="count20x20"
                        class="text-lg font-medium text-gray-700"
                        >20x20 Puzzles
                        <span class="text-sm text-gray-500"
                            >(20 words)</span
                        ></label
                    >
                    <input
                        type="number"
                        id="count20x20"
                        min="0"
                        max="100"
                        value="0"
                        class="w-24 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-center"
                    />
                </div>

                <!-- 30x30 Input -->
                <div class="flex items-center justify-between">
                    <label
                        for="count30x30"
                        class="text-lg font-medium text-gray-700"
                        >30x30 Puzzles
                        <span class="text-sm text-gray-500"
                            >(40 words)</span
                        ></label
                    >
                    <input
                        type="number"
                        id="count30x30"
                        min="0"
                        max="100"
                        value="0"
                        class="w-24 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-center"
                    />
                </div>

                <!-- 40x40 Input -->
                <div class="flex items-center justify-between">
                    <label
                        for="count40x40"
                        class="text-lg font-medium text-gray-700"
                        >40x40 Puzzles
                        <span class="text-sm text-gray-500"
                            >(50 words)</span
                        ></label
                    >
                    <input
                        type="number"
                        id="count40x40"
                        min="0"
                        max="100"
                        value="0"
                        class="w-24 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-center"
                    />
                </div>
            </div>

            <!-- Total Counter -->
            <div class="text-center my-6">
                <strong class="text-lg"
                    >Total:
                    <span id="totalCount" class="text-blue-600">0</span
                    >/100</strong
                >
                <div id="remainingText" class="text-gray-600">
                    (<span id="remainingCount">100</span> remaining)
                </div>
            </div>

            <!-- Generate Button -->
            <button
                id="generateBtn"
                class="w-full bg-blue-600 text-white font-bold px-6 py-3 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-all duration-200 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed"
            >
                Generate PDF
            </button>

            <!-- Status/Loading Message -->
            <div
                id="status"
                class="text-center text-gray-500 mt-6 min-h-[1.5em]"
            >
                <!-- Status messages will appear here -->
            </div>
        </div>

        <script>
            // --- CONFIGURATION ---
            const MAX_TOTAL_PUZZLES = 100;
            const PUZZLE_CONFIGS = {
                "20x20": { gridSize: 20, wordCount: 20, keyLayout: "2x2" },
                "30x30": { gridSize: 30, wordCount: 40, keyLayout: "2x2" },
                "40x40": { gridSize: 40, wordCount: 50, keyLayout: "1x2" },
            };
            // All 8 directions: [rowChange, colChange]
            const DIRECTIONS = [
                [0, 1], // Horizontal (Right)
                [1, 0], // Vertical (Down)
                [1, 1], // Diagonal (Down-Right)
                [0, -1], // Horizontal (Left)
                [-1, 0], // Vertical (Up)
                [-1, -1], // Diagonal (Up-Left)
                [1, -1], // Diagonal (Down-Left)
                [-1, 1], // Diagonal (Up-Right)
            ];

            // --- DOM ELEMENTS ---
            const count20x20 = document.getElementById("count20x20");
            const count30x30 = document.getElementById("count30x30");
            const count40x40 = document.getElementById("count40x40");
            const totalCountEl = document.getElementById("totalCount");
            const remainingCountEl = document.getElementById("remainingCount");
            const remainingTextEl = document.getElementById("remainingText");
            const generateBtn = document.getElementById("generateBtn");
            const statusEl = document.getElementById("status");

            // --- EVENT LISTENERS ---
            generateBtn.addEventListener("click", handleGenerateClick);
            [count20x20, count30x30, count40x40].forEach((input) => {
                input.addEventListener("input", updateCounter);
            });
            // Call once on load to set initial state
            updateCounter();

            /**
             * Updates the total puzzle counter and button state
             */
            function updateCounter() {
                const count20 = parseInt(count20x20.value, 10) || 0;
                const count30 = parseInt(count30x30.value, 10) || 0;
                const count40 = parseInt(count40x40.value, 10) || 0;

                const total = count20 + count30 + count40;
                const remaining = MAX_TOTAL_PUZZLES - total;

                totalCountEl.textContent = total;

                if (total > MAX_TOTAL_PUZZLES) {
                    remainingTextEl.textContent = `Too many! (${total - MAX_TOTAL_PUZZLES} over)`;
                    remainingTextEl.classList.add("text-red-600");
                    generateBtn.disabled = true;
                } else if (total === 0) {
                    remainingCountEl.textContent = remaining;
                    remainingTextEl.textContent = `(${remaining} remaining)`;
                    remainingTextEl.classList.remove("text-red-600");
                    generateBtn.disabled = true; // Don't generate 0 puzzles
                } else {
                    remainingCountEl.textContent = remaining;
                    remainingTextEl.textContent = `(${remaining} remaining)`;
                    remainingTextEl.classList.remove("text-red-600");
                    generateBtn.disabled = false;
                }
            }

            /**
             * Main function to handle the "Generate" button click
             */
            async function handleGenerateClick() {
                // Get counts
                const counts = {
                    "20x20": parseInt(count20x20.value, 10) || 0,
                    "30x30": parseInt(count30x30.value, 10) || 0,
                    "40x40": parseInt(count40x40.value, 10) || 0,
                };

                // Build request list
                const puzzleRequests = [];
                let totalWords = 0;
                for (const type of ["20x20", "30x30", "40x40"]) {
                    const count = counts[type];
                    if (count > 0) {
                        const config = PUZZLE_CONFIGS[type];
                        puzzleRequests.push({ type, count, ...config });
                        totalWords += count * config.wordCount;
                    }
                }

                if (totalWords === 0) {
                    setStatus("Please select at least one puzzle.", "error");
                    return;
                }

                // Disable UI
                setLoadingState(true);
                setStatus("Generating... this may take a moment.", "loading");

                try {
                    // 1. Fetch all words
                    setStatus(
                        `Fetching ${totalWords} random words...`,
                        "loading",
                    );
                    const words = await fetchWords(totalWords);
                    if (!words) return; // Error handled in fetchWords

                    const allPuzzles = [];
                    let currentWordIndex = 0;
                    let puzzleCounter = 0; // This will be the originalIndex

                    // 2. Generate each puzzle
                    for (const request of puzzleRequests) {
                        const config = request;
                        for (let i = 0; i < request.count; i++) {
                            setStatus(
                                `Generating puzzle ${puzzleCounter + 1} of ${totalWords / (config.wordCount / request.count)} (${config.type})...`,
                                "loading",
                            );
                            const wordsForPuzzle = words.slice(
                                currentWordIndex,
                                currentWordIndex + config.wordCount,
                            );
                            currentWordIndex += config.wordCount;

                            const puzzleData = generatePuzzle(
                                wordsForPuzzle,
                                config.gridSize,
                            );

                            allPuzzles.push({
                                ...puzzleData,
                                ...config,
                                originalIndex: puzzleCounter, // Add the original 0-based index
                            });
                            puzzleCounter++;
                        }
                    }

                    // 3. Create the PDF
                    setStatus("Compiling PDF...", "loading");
                    await generatePDF(allPuzzles);

                    setStatus("Success! Check your downloads.", "success");
                } catch (error) {
                    console.error("Error generating word searches:", error);
                    setStatus(`Error: ${error.message}`, "error");
                } finally {
                    // Re-enable UI
                    setLoadingState(false);
                }
            }

            /**
         * Selects random words from a built-in dictionary.
...
         * @param {number} totalWords - The total number of words to select
         * @returns {Promise<string[] | null>} A list of words or null on failure
         */

            let _cachedDictionary = null; // Cache for the parsed dictionary

            // Store the dictionary as a single string to avoid parsing a giant array on load
            // --- YOU CAN PASTE YOUR 2000+ WORDS HERE ---
            // (Just make sure they are separated by spaces or new lines)
            const dictionaryString = `
            a
abandon
ability
able
abortion
about
above
abroad
absence
absolute
absolutely
absorb
abuse
academic
accept
access
accident
accompany
accomplish
according
account
accurate
accuse
achieve
achievement
acid
acknowledge
acquire
across
act
action
active
activist
activity
actor
actress
actual
actually
ad
adapt
add
addition
additional
address
adequate
adjust
adjustment
administration
administrator
admire
admission
admit
adolescent
adopt
adult
advance
advanced
advantage
adventure
advertising
advice
advise
adviser
advocate
affair
affect
afford
afraid
African
African-American
after
afternoon
again
against
age
agency
agenda
agent
aggressive
ago
agree
agreement
agricultural
ah
ahead
aid
aide
AIDS
aim
air
aircraft
airline
airport
album
alcohol
alive
all
alliance
allow
ally
almost
alone
along
already
also
alter
alternative
although
always
AM
amazing
American
among
amount
analysis
analyst
analyze
ancient
and
anger
angle
angry
animal
anniversary
announce
annual
another
answer
anticipate
anxiety
any
anybody
anymore
anyone
anything
anyway
anywhere
apart
apartment
apparent
apparently
appeal
appear
appearance
apple
application
apply
appoint
appointment
appreciate
approach
appropriate
approval
approve
approximately
Arab
architect
area
argue
argument
arise
arm
armed
army
around
arrange
arrangement
arrest
arrival
arrive
art
article
artist
artistic
as
Asian
aside
ask
asleep
aspect
assault
assert
assess
assessment
asset
assign
assignment
assist
assistance
assistant
associate
association
assume
assumption
assure
at
athlete
athletic
atmosphere
attach
attack
attempt
attend
attention
attitude
attorney
attract
attractive
attribute
audience
author
authority
auto
available
average
avoid
award
aware
awareness
away
awful
baby
back
background
bad
badly
bag
bake
balance
ball
ban
band
bank
bar
barely
barrel
barrier
base
baseball
basic
basically
basis
basket
basketball
bathroom
battery
battle
be
beach
bean
bear
beat
beautiful
beauty
because
become
bed
bedroom
beer
before
begin
beginning
behavior
behind
being
belief
believe
bell
belong
below
belt
bench
bend
beneath
benefit
beside
besides
best
bet
better
between
beyond
Bible
big
bike
bill
billion
bind
biological
bird
birth
birthday
bit
bite
black
blade
blame
blanket
blind
block
blood
blow
blue
board
boat
body
bomb
bombing
bond
bone
book
boom
boot
border
born
borrow
boss
both
bother
bottle
bottom
boundary
bowl
box
boy
boyfriend
brain
branch
brand
bread
break
breakfast
breast
breath
breathe
brick
bridge
brief
briefly
bright
brilliant
bring
British
broad
broken
brother
brown
brush
buck
budget
build
building
bullet
bunch
burden
burn
bury
bus
business
busy
but
butter
button
buy
buyer
by
cabin
cabinet
cable
cake
calculate
call
camera
camp
campaign
campus
can
Canadian
cancer
candidate
cap
capability
capable
capacity
capital
captain
capture
car
carbon
card
care
career
careful
carefully
carrier
carry
case
cash
cast
cat
catch
category
Catholic
cause
ceiling
celebrate
celebration
celebrity
cell
center
central
century
CEO
ceremony
certain
certainly
chain
chair
chairman
challenge
chamber
champion
championship
chance
change
changing
channel
chapter
character
characteristic
characterize
charge
charity
chart
chase
cheap
check
cheek
cheese
chef
chemical
chest
chicken
chief
child
childhood
Chinese
chip
chocolate
choice
cholesterol
choose
Christian
Christmas
church
cigarette
circle
circumstance
cite
citizen
city
civil
civilian
claim
class
classic
classroom
clean
clear
clearly
client
climate
climb
clinic
clinical
clock
close
closely
closer
clothes
clothing
cloud
club
clue
cluster
coach
coal
coalition
coast
coat
code
coffee
cognitive
cold
collapse
colleague
collect
collection
collective
college
colonial
color
column
combination
combine
come
comedy
comfort
comfortable
command
commander
comment
commercial
commission
commit
commitment
committee
common
communicate
communication
community
company
compare
comparison
compete
competition
competitive
competitor
complain
complaint
complete
completely
complex
complicated
component
compose
composition
comprehensive
computer
concentrate
concentration
concept
concern
concerned
concert
conclude
conclusion
concrete
condition
conduct
conference
confidence
confident
confirm
conflict
confront
confusion
Congress
congressional
connect
connection
consciousness
consensus
consequence
conservative
consider
considerable
consideration
consist
consistent
constant
constantly
constitute
constitutional
construct
construction
consultant
consume
consumer
consumption
contact
contain
container
contemporary
content
contest
context
continue
continued
contract
contrast
contribute
contribution
control
controversial
controversy
convention
conventional
conversation
convert
conviction
convince
cook
cookie
cooking
cool
cooperation
cop
cope
copy
core
corn
corner
corporate
corporation
correct
correspondent
cost
cotton
couch
could
council
counselor
count
counter
country
county
couple
courage
course
court
cousin
cover
coverage
cow
crack
craft
crash
crazy
cream
create
creation
creative
creature
credit
crew
crime
criminal
crisis
criteria
critic
critical
criticism
criticize
crop
cross
crowd
crucial
cry
cultural
culture
cup
curious
current
currently
curriculum
custom
customer
cut
cycle
dad
daily
damage
dance
danger
dangerous
dare
dark
darkness
data
date
daughter
day
dead
deal
dealer
dear
death
debate
debt
decade
decide
decision
deck
declare
decline
decrease
deep
deeply
deer
defeat
defend
defendant
defense
defensive
deficit
define
definitely
definition
degree
delay
deliver
delivery
demand
democracy
Democrat
democratic
demonstrate
demonstration
deny
department
depend
dependent
depending
depict
depression
depth
deputy
derive
describe
description
desert
deserve
design
designer
desire
desk
desperate
despite
destroy
destruction
detail
detailed
detect
determine
develop
developing
development
device
devote
dialogue
die
diet
differ
difference
different
differently
difficult
difficulty
dig
digital
dimension
dining
dinner
direct
direction
directly
director
dirt
dirty
disability
disagree
disappear
disaster
discipline
discourse
discover
discovery
discrimination
discuss
discussion
disease
dish
dismiss
disorder
display
dispute
distance
distant
distinct
distinction
distinguish
distribute
distribution
district
diverse
diversity
divide
division
divorce
DNA
do
doctor
document
dog
domestic
dominant
dominate
door
double
doubt
down
downtown
dozen
draft
drag
drama
dramatic
dramatically
draw
drawing
dream
dress
drink
drive
driver
drop
drug
dry
due
during
dust
duty
each
eager
ear
early
earn
earnings
earth
ease
easily
east
eastern
easy
eat
economic
economics
economist
economy
edge
edition
editor
educate
education
educational
educator
effect
effective
effectively
efficiency
efficient
effort
egg
eight
either
elderly
elect
election
electric
electricity
electronic
element
elementary
eliminate
elite
else
elsewhere
e-mail
embrace
emerge
emergency
emission
emotion
emotional
emphasis
emphasize
employ
employee
employer
employment
empty
enable
encounter
encourage
end
enemy
energy
enforcement
engage
engine
engineer
engineering
English
enhance
enjoy
enormous
enough
ensure
enter
enterprise
entertainment
entire
entirely
entrance
entry
environment
environmental
episode
equal
equally
equipment
era
error
escape
especially
essay
essential
essentially
establish
establishment
estate
estimate
etc
ethics
ethnic
European
evaluate
evaluation
even
evening
event
eventually
ever
every
everybody
everyday
everyone
everything
everywhere
evidence
evolution
evolve
exact
exactly
examination
examine
example
exceed
excellent
except
exception
exchange
exciting
executive
exercise
exhibit
exhibition
exist
existence
existing
expand
expansion
expect
expectation
expense
expensive
experience
experiment
expert
explain
explanation
explode
explore
explosion
expose
exposure
express
expression
extend
extension
extensive
extent
external
extra
extraordinary
extreme
extremely
eye
fabric
face
facility
fact
factor
factory
faculty
fade
fail
failure
fair
fairly
faith
fall
false
familiar
family
famous
fan
fantasy
far
farm
farmer
fashion
fast
fat
fate
father
fault
favor
favorite
fear
feature
federal
fee
feed
feel
feeling
fellow
female
fence
few
fewer
fiber
fiction
field
fifteen
fifth
fifty
fight
fighter
fighting
figure
file
fill
film
final
finally
finance
financial
find
finding
fine
finger
finish
fire
firm
first
fish
fishing
fit
fitness
five
fix
flag
flame
flat
flavor
flee
flesh
flight
float
floor
flow
flower
fly
focus
folk
follow
following
food
foot
football
for
force
foreign
forest
forever
forget
form
formal
formation
former
formula
forth
fortune
forward
found
foundation
founder
four
fourth
frame
framework
free
freedom
freeze
French
frequency
frequent
frequently
fresh
friend
friendly
friendship
from
front
fruit
frustration
fuel
full
fully
fun
function
fund
fundamental
funding
funeral
funny
furniture
furthermore
future
gain
galaxy
gallery
game
gang
gap
garage
garden
garlic
gas
gate
gather
gay
gaze
gear
gender
gene
general
generally
generate
generation
genetic
gentleman
gently
German
gesture
get
ghost
giant
gift
gifted
girl
girlfriend
give
given
glad
glance
glass
global
glove
go
goal
God
gold
golden
golf
good
government
governor
grab
grade
gradually
graduate
grain
grand
grandfather
grandmother
grant
grass
grave
gray
great
greatest
green
grocery
ground
group
grow
growing
growth
guarantee
guard
guess
guest
guide
guideline
guilty
gun
guy
habit
habitat
hair
half
hall
hand
handful
handle
hang
happen
happy
hard
hardly
hat
hate
have
he
head
headline
headquarters
health
healthy
hear
hearing
heart
heat
heaven
heavily
heavy
heel
height
helicopter
hell
hello
help
helpful
her
here
heritage
hero
herself
hey
hi
hide
high
highlight
highly
highway
hill
him
himself
hip
hire
his
historian
historic
historical
history
hit
hold
hole
holiday
holy
home
homeless
honest
honey
honor
hope
horizon
horror
horse
hospital
host
hot
hotel
hour
house
household
housing
how
however
huge
human
humor
hundred
hungry
hunter
hunting
hurt
husband
hypothesis
I
ice
idea
ideal
identification
identify
identity
ie
if
ignore
ill
illegal
illness
illustrate
image
imagination
imagine
immediate
immediately
immigrant
immigration
impact
implement
implication
imply
importance
important
impose
impossible
impress
impression
impressive
improve
improvement
in
incentive
incident
include
including
income
incorporate
increase
increased
increasing
increasingly
incredible
indeed
independence
independent
index
Indian
indicate
indication
individual
industrial
industry
infant
infection
inflation
influence
inform
information
ingredient
initial
initially
initiative
injury
inner
innocent
inquiry
inside
insight
insist
inspire
install
instance
instead
institution
institutional
instruction
instructor
instrument
insurance
intellectual
intelligence
intend
intense
intensity
intention
interaction
interest
interested
interesting
internal
international
Internet
interpret
interpretation
intervention
interview
into
introduce
introduction
invasion
invest
investigate
investigation
investigator
investment
investor
invite
involve
involved
involvement
Iraqi
Irish
iron
Islamic
island
Israeli
issue
it
Italian
item
its
itself
jacket
jail
Japanese
jet
Jew
Jewish
job
join
joint
joke
journal
journalist
journey
joy
judge
judgment
juice
jump
junior
jury
just
justice
justify
keep
key
kick
kid
kill
killer
killing
kind
king
kiss
kitchen
knee
knife
knock
know
knowledge
lab
label
labor
laboratory
lack
lady
lake
land
landscape
language
lap
large
largely
last
late
later
Latin
latter
laugh
launch
law
lawn
lawsuit
lawyer
lay
layer
lead
leader
leadership
leading
leaf
league
lean
learn
learning
least
leather
leave
left
leg
legacy
legal
legend
legislation
legitimate
lemon
length
less
lesson
let
letter
level
liberal
library
license
lie
life
lifestyle
lifetime
lift
light
like
likely
limit
limitation
limited
line
link
lip
list
listen
literally
literary
literature
little
live
living
load
loan
local
locate
location
lock
long
long-term
look
loose
lose
loss
lost
lot
lots
loud
love
lovely
lover
low
lower
luck
lucky
lunch
lung
machine
mad
magazine
mail
main
mainly
maintain
maintenance
major
majority
make
maker
makeup
male
mall
man
manage
management
manager
manner
manufacturer
manufacturing
many
map
margin
mark
market
marketing
marriage
married
marry
mask
mass
massive
master
match
material
math
matter
may
maybe
mayor
me
meal
mean
meaning
meanwhile
measure
measurement
meat
mechanism
media
medical
medication
medicine
medium
meet
meeting
member
membership
memory
mental
mention
menu
mere
merely
mess
message
metal
meter
method
Mexican
middle
might
military
milk
million
mind
mine
minister
minor
minority
minute
miracle
mirror
miss
missile
mission
mistake
mix
mixture
mm-hmm
mode
model
moderate
modern
modest
mom
moment
money
monitor
month
mood
moon
moral
more
moreover
morning
mortgage
most
mostly
mother
motion
motivation
motor
mount
mountain
mouse
mouth
move
movement
movie
Mr
Mrs
Ms
much
multiple
murder
muscle
museum
music
musical
musician
Muslim
must
mutual
my
myself
mystery
myth
naked
name
narrative
narrow
nation
national
native
natural
naturally
nature
near
nearby
nearly
necessarily
necessary
neck
need
negative
negotiate
negotiation
neighbor
neighborhood
neither
nerve
nervous
net
network
never
nevertheless
new
newly
news
newspaper
next
nice
night
nine
no
nobody
nod
noise
nomination
none
nonetheless
nor
normal
normally
north
northern
nose
not
note
nothing
notice
notion
novel
now
nowhere
n't
nuclear
number
numerous
nurse
nut
object
objective
obligation
observation
observe
observer
obtain
obvious
obviously
occasion
occasionally
occupation
occupy
occur
ocean
odd
odds
of
off
offense
offensive
offer
office
officer
official
often
oh
oil
ok
okay
old
Olympic
on
once
one
ongoing
onion
online
only
onto
open
opening
operate
operating
operation
operator
opinion
opponent
opportunity
oppose
opposite
opposition
option
or
orange
order
ordinary
organic
organization
organize
orientation
origin
original
originally
other
others
otherwise
ought
our
ourselves
out
outcome
outside
oven
over
overall
overcome
overlook
owe
own
owner
pace
pack
package
page
pain
painful
paint
painter
painting
pair
pale
Palestinian
palm
pan
panel
pant
paper
parent
park
parking
part
participant
participate
participation
particular
particularly
partly
partner
partnership
party
pass
passage
passenger
passion
past
patch
path
patient
pattern
pause
pay
payment
PC
peace
peak
peer
penalty
people
pepper
per
perceive
percentage
perception
perfect
perfectly
perform
performance
perhaps
period
permanent
permission
permit
person
personal
personality
personally
personnel
perspective
persuade
pet
phase
phenomenon
philosophy
phone
photo
photograph
photographer
phrase
physical
physically
physician
piano
pick
picture
pie
piece
pile
pilot
pine
pink
pipe
pitch
place
plan
plane
planet
planning
plant
plastic
plate
platform
play
player
please
pleasure
plenty
plot
plus
PM
pocket
poem
poet
poetry
point
pole
police
policy
political
politically
politician
politics
poll
pollution
pool
poor
pop
popular
population
porch
port
portion
portrait
portray
pose
position
positive
possess
possibility
possible
possibly
post
pot
potato
potential
potentially
pound
pour
poverty
powder
power
powerful
practical
practice
pray
prayer
precisely
predict
prefer
preference
pregnancy
pregnant
preparation
prepare
prescription
presence
present
presentation
preserve
president
presidential
press
pressure
pretend
pretty
prevent
previous
previously
price
pride
priest
primarily
primary
prime
principal
principle
print
prior
priority
prison
prisoner
privacy
private
probably
problem
procedure
proceed
process
produce
producer
product
production
profession
professional
professor
profile
profit
program
progress
project
prominent
promise
promote
prompt
proof
proper
properly
property
proportion
proposal
propose
proposed
prosecutor
prospect
protect
protection
protein
protest
proud
prove
provide
provider
province
provision
psychological
psychologist
psychology
public
publication
publicly
publish
publisher
pull
punishment
purchase
pure
purpose
pursue
push
put
qualify
quality
quarter
quarterback
question
quick
quickly
quiet
quietly
quit
quite
quote
race
racial
radical
radio
rail
rain
raise
range
rank
rapid
rapidly
rare
rarely
rate
rather
rating
ratio
raw
reach
react
reaction
read
reader
reading
ready
real
reality
realize
really
reason
reasonable
recall
receive
recent
recently
recipe
recognition
recognize
recommend
recommendation
record
recording
recover
recovery
recruit
red
reduce
reduction
refer
reference
reflect
reflection
reform
refugee
refuse
regard
regarding
regardless
regime
region
regional
register
regular
regularly
regulate
regulation
reinforce
reject
relate
relation
relationship
relative
relatively
relax
release
relevant
relief
religion
religious
rely
remain
remaining
remarkable
remember
remind
remote
remove
repeat
repeatedly
replace
reply
report
reporter
represent
representation
representative
Republican
reputation
request
require
requirement
research
researcher
resemble
reservation
resident
resist
resistance
resolution
resolve
resort
resource
respect
respond
respondent
response
responsibility
responsible
rest
restaurant
restore
restriction
result
retain
retire
retirement
return
reveal
revenue
review
revolution
rhythm
rice
rich
rid
ride
rifle
right
ring
rise
risk
river
road
rock
role
roll
romantic
roof
room
root
rope
rose
rough
roughly
round
route
routine
row
rub
rule
run
running
rural
rush
Russian
sacred
sad
safe
safety
sake
salad
salary
sale
sales
salt
same
sample
sanction
sand
satellite
satisfaction
satisfy
sauce
save
saving
say
scale
scandal
scared
scenario
scene
schedule
scheme
scholar
scholarship
school
science
scientific
scientist
scope
score
scream
screen
script
sea
search
season
seat
second
secret
secretary
section
sector
secure
security
see
seed
seek
seem
segment
seize
select
selection
self
sell
Senate
senator
send
senior
sense
sensitive
sentence
separate
sequence
series
serious
seriously
serve
service
session
set
setting
settle
settlement
seven
several
severe
sex
sexual
shade
shadow
shake
shall
shape
share
sharp
she
sheet
shelf
shell
shelter
shift
shine
ship
shirt
shit
shock
shoe
shoot
shooting
shop
shopping
shore
short
shortly
shot
should
shoulder
shout
show
shower
shrug
shut
sick
side
sigh
sight
sign
signal
significance
significant
significantly
silence
silent
silver
similar
similarly
simple
simply
sin
since
sing
singer
single
sink
sir
sister
sit
site
situation
six
size
ski
skill
skin
sky
slave
sleep
slice
slide
slight
slightly
slip
slow
slowly
small
smart
smell
smile
smoke
smooth
snap
snow
so
so-called
soccer
social
society
soft
software
soil
solar
soldier
solid
solution
solve
some
somebody
somehow
someone
something
sometimes
somewhat
somewhere
son
song
soon
sophisticated
sorry
sort
soul
sound
soup
source
south
southern
Soviet
space
Spanish
speak
speaker
special
specialist
species
specific
specifically
speech
speed
spend
spending
spin
spirit
spiritual
split
spokesman
sport
spot
spread
spring
square
squeeze
stability
stable
staff
stage
stair
stake
stand
standard
standing
star
stare
start
state
statement
station
statistics
status
stay
steady
steal
steel
step
stick
still
stir
stock
stomach
stone
stop
storage
store
storm
story
straight
strange
stranger
strategic
strategy
stream
street
strength
strengthen
stress
stretch
strike
string
strip
stroke
strong
strongly
structure
struggle
student
studio
study
stuff
stupid
style
subject
submit
subsequent
substance
substantial
succeed
success
successful
successfully
such
sudden
suddenly
sue
suffer
sufficient
sugar
suggest
suggestion
suicide
suit
summer
summit
sun
super
supply
support
supporter
suppose
supposed
Supreme
sure
surely
surface
surgery
surprise
surprised
surprising
surprisingly
surround
survey
survival
survive
survivor
suspect
sustain
swear
sweep
sweet
swim
swing
switch
symbol
symptom
system
table
tablespoon
tactic
tail
take
tale
talent
talk
tall
tank
tap
tape
target
task
taste
tax
taxpayer
tea
teach
teacher
teaching
team
tear
teaspoon
technical
technique
technology
teen
teenager
telephone
telescope
television
tell
temperature
temporary
ten
tend
tendency
tennis
tension
tent
term
terms
terrible
territory
terror
terrorism
terrorist
test
testify
testimony
testing
text
than
thank
thanks
that
the
theater
their
them
theme
themselves
then
theory
therapy
there
therefore
these
they
thick
thin
thing
think
thinking
third
thirty
this
those
though
thought
thousand
threat
threaten
three
throat
through
throughout
throw
thus
ticket
tie
tight
time
tiny
tip
tire
tired
tissue
title
to
tobacco
today
toe
together
tomato
tomorrow
tone
tongue
tonight
too
tool
tooth
top
topic
toss
total
totally
touch
tough
tour
tourist
tournament
toward
towards
tower
town
toy
trace
track
trade
tradition
traditional
traffic
tragedy
trail
train
training
transfer
transform
transformation
transition
translate
transportation
travel
treat
treatment
treaty
tree
tremendous
trend
trial
tribe
trick
trip
troop
trouble
truck
true
truly
trust
truth
try
tube
tunnel
turn
TV
twelve
twenty
twice
twin
two
type
typical
typically
ugly
ultimate
ultimately
unable
uncle
under
undergo
understand
understanding
unfortunately
uniform
union
unique
unit
United
universal
universe
university
unknown
unless
unlike
unlikely
until
unusual
up
upon
upper
urban
urge
us
use
used
useful
user
usual
usually
utility
vacation
valley
valuable
value
variable
variation
variety
various
vary
vast
vegetable
vehicle
venture
version
versus
very
vessel
veteran
via
victim
victory
video
view
viewer
village
violate
violation
violence
violent
virtually
virtue
virus
visible
vision
visit
visitor
visual
vital
voice
volume
volunteer
vote
voter
vs
vulnerable
wage
wait
wake
walk
wall
wander
want
war
warm
warn
warning
wash
waste
watch
water
wave
way
we
weak
wealth
wealthy
weapon
wear
weather
wedding
week
weekend
weekly
weigh
weight
welcome
welfare
well
west
western
wet
what
whatever
wheel
when
whenever
where
whereas
whether
which
while
whisper
white
who
whole
whom
whose
why
wide
widely
widespread
wife
wild
will
willing
win
wind
window
wine
wing
winner
winter
wipe
wire
wisdom
wise
wish
with
withdraw
within
without
witness
woman
wonder
wonderful
wood
wooden
word
work
worker
working
works
workshop
world
worried
worry
worth
would
wound
wrap
write
writer
writing
wrong
yard
yeah
year
yell
yellow
yes
yesterday
yet
yield
you
young
your
yours
yourself
youth
zone
        `;

            /**
             * Parses the dictionary string *once* and caches the filtered result.
             */
            function getDictionary() {
                if (_cachedDictionary) {
                    return _cachedDictionary;
                }

                // This part only runs once
                console.log("Parsing dictionary string for the first time...");

                const allWords = dictionaryString
                    .trim() // Remove leading/trailing whitespace
                    .split(/\s+/) // Split on one or more whitespace characters
                    .filter((w) => w.length > 0) // Remove empty strings
                    .map((w) => w.toLowerCase()); // Normalize to lowercase

                // Filter for valid word lengths
                _cachedDictionary = allWords.filter(
                    (w) => w.length >= 3 && w.length <= 12,
                );

                if (_cachedDictionary.length < 100) {
                    console.warn(
                        "Dictionary has very few valid words (length > 2 and <= 12).",
                    );
                }

                return _cachedDictionary;
            }

            /**
             * Selects random words from the built-in dictionary.
             * This is now much more efficient for large dictionaries.
             * @param {number} totalWords - The total number of words to select
             * @returns {Promise<string[] | null>} A list of words or null on failure
             */
            async function fetchWords(totalWords) {
                setStatus("Parsing local dictionary...", "loading");

                // Use a timeout to allow the "Parsing..." message to render
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        try {
                            const dictionary = getDictionary(); // Gets pre-filtered, cached list

                            if (dictionary.length === 0) {
                                throw new Error(
                                    "No valid words found in the dictionary.",
                                );
                            }

                            // Use a Set to efficiently get unique words
                            const selectedWords = new Set();

                            // Safety check: prevent infinite loop if totalWords > dictionary.length
                            const maxAttempts = totalWords * 5;
                            let attempts = 0;
                            const dictionaryLength = dictionary.length;

                            while (
                                selectedWords.size < totalWords &&
                                attempts < maxAttempts
                            ) {
                                const randomIndex = Math.floor(
                                    Math.random() * dictionaryLength,
                                );
                                selectedWords.add(dictionary[randomIndex]);
                                attempts++;
                            }

                            let finalWords = Array.from(selectedWords);

                            // If we still don't have enough unique words, fill the rest with random (non-unique) words
                            if (finalWords.length < totalWords) {
                                console.warn(
                                    `Warning: Could not find ${totalWords} unique words. Adding duplicates.`,
                                );
                                setStatus(
                                    "Warning: Not enough unique words. Adding duplicates.",
                                    "loading",
                                );

                                while (finalWords.length < totalWords) {
                                    const randomIndex = Math.floor(
                                        Math.random() * dictionaryLength,
                                    );
                                    finalWords.push(dictionary[randomIndex]);
                                }
                            }

                            resolve(finalWords);
                        } catch (error) {
                            console.error("Dictionary Error:", error);
                            setStatus(`Error: ${error.message}`, "error");
                            setLoadingState(false);
                            resolve(null); // Resolve with null to stop execution in handleGenerateClick
                        }
                    }, 50); // 50ms delay to allow UI update
                });
            }

            /**
             * Generates a single word search puzzle and its solution
             * @param {string[]} words - The list of words for this puzzle
             * @param {number} gridSize - The size of the grid (e.g., 20 for 20x20)
             * @returns {{puzzleGrid: string[][], solutionGrid: string[][], wordList: string[]}}
             */
            function generatePuzzle(words, gridSize) {
                let puzzleGrid = createEmptyGrid(null, gridSize);
                let solutionGrid = createEmptyGrid(" ", gridSize);
                const placedWords = [];
                const placedWordData = []; // To store coordinates for strikethrough

                for (const word of words) {
                    const upperWord = word.toUpperCase();
                    let placed = false;

                    // Try to place the word multiple times
                    for (let i = 0; i < 100; i++) {
                        const direction =
                            DIRECTIONS[
                                Math.floor(Math.random() * DIRECTIONS.length)
                            ];
                        const startRow = Math.floor(Math.random() * gridSize);
                        const startCol = Math.floor(Math.random() * gridSize);

                        if (
                            canPlaceWord(
                                puzzleGrid,
                                upperWord,
                                startRow,
                                startCol,
                                direction,
                                gridSize,
                            )
                        ) {
                            placeWord(
                                puzzleGrid,
                                solutionGrid,
                                upperWord,
                                startRow,
                                startCol,
                                direction,
                            );
                            placedWords.push(upperWord);

                            // Store coordinates for the answer key
                            const endRow =
                                startRow +
                                (upperWord.length - 1) * direction[0];
                            const endCol =
                                startCol +
                                (upperWord.length - 1) * direction[1];
                            placedWordData.push({
                                r1: startRow,
                                c1: startCol,
                                r2: endRow,
                                c2: endCol,
                            });

                            placed = true;
                            break;
                        }
                    }
                    if (!placed) {
                        console.warn(`Could not place word: ${word}`);
                    }
                }

                // Fill empty spots in puzzle grid with random letters
                fillRandomLetters(puzzleGrid);

                // Return the grids and the sorted list of placed words
                return {
                    puzzleGrid,
                    solutionGrid,
                    wordList: placedWords.sort(),
                    placedWordData,
                };
            }

            /**
             * Checks if a word can be placed on the grid
             * @param {string[][]} grid
             * @param {string} word
             * @param {number} r - Start row
             * @param {number} c - Start column
             * @param {number[]} dir - Direction [dr, dc]
             * @param {number} gridSize
             * @returns {boolean}
             */
            function canPlaceWord(grid, word, r, c, dir, gridSize) {
                for (let i = 0; i < word.length; i++) {
                    const newR = r + i * dir[0];
                    const newC = c + i * dir[1];

                    // 1. Check bounds
                    if (
                        newR < 0 ||
                        newR >= gridSize ||
                        newC < 0 ||
                        newC >= gridSize
                    ) {
                        return false;
                    }

                    // 2. Check collisions
                    const existingChar = grid[newR][newC];
                    if (existingChar !== null && existingChar !== word[i]) {
                        return false;
                    }
                }
                return true;
            }

            /**
             * Places the word on both the puzzle and solution grids
             * @param {string[][]} puzzleGrid
             * @param {string[][]} solutionGrid
             * @param {string} word
             * @param {number} r - Start row
             * @param {number} c - Start column
             * @param {number[]} dir - Direction [dr, dc]
             */
            function placeWord(puzzleGrid, solutionGrid, word, r, c, dir) {
                for (let i = 0; i < word.length; i++) {
                    const newR = r + i * dir[0];
                    const newC = c + i * dir[1];
                    puzzleGrid[newR][newC] = word[i];
                    solutionGrid[newR][newC] = word[i];
                }
            }

            /**
             * Creates an empty 2D array
             * @param {*} fillWith - The value to fill the grid with
             * @param {number} gridSize
             * @returns {string[][]}
             */
            function createEmptyGrid(fillWith, gridSize) {
                return Array(gridSize)
                    .fill(null)
                    .map(() => Array(gridSize).fill(fillWith));
            }

            /**
             * Fills all null spots in a grid with random uppercase letters
             * @param {string[][]} grid
             */
            function fillRandomLetters(grid) {
                const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                const gridSize = grid.length;
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        if (grid[r][c] === null) {
                            grid[r][c] =
                                alphabet[
                                    Math.floor(Math.random() * alphabet.length)
                                ];
                        }
                    }
                }
            }

            /**
             * Helper function to draw a single answer grid within a bounding box
             */
            function drawAnswerGrid(
                doc,
                puzzle,
                boxX,
                boxY,
                boxW,
                boxH,
                title,
            ) {
                const { gridSize, puzzleGrid, placedWordData } = puzzle;

                // --- 1. Draw Title for this grid ---
                doc.setFontSize(10);
                doc.setFont("helvetica", "bold");
                doc.text(title, boxX + boxW / 2, boxY, { align: "center" });

                const gridTopY_inBox = boxY + 8; // 8mm for title
                const availableGridHeight = boxH - 8;

                // --- 2. Calculate Dynamic Font Size ---
                doc.setFont("courier", "normal");
                const gridString = Array(gridSize).fill("W").join(" ");
                const scaleFactor = doc.internal.scaleFactor;

                const fontMaxWidth =
                    (boxW * scaleFactor) / doc.getStringUnitWidth(gridString);
                const lineH_at_1pt = 1 * 0.352778 * 1.1;
                const fontMaxHeight =
                    availableGridHeight / (gridSize * lineH_at_1pt);

                let gridFontSize = Math.min(fontMaxWidth, fontMaxHeight);
                gridFontSize = Math.max(2, Math.min(10, gridFontSize)); // Clamp 2pt to 10pt

                doc.setFontSize(gridFontSize);

                // --- 3. Calculate Final Grid Dimensions & Centering ---
                const lineH = gridFontSize * 0.352778 * 1.1;
                const gridTextWidth =
                    (doc.getStringUnitWidth(gridString) * gridFontSize) /
                    scaleFactor;
                const gridX_inBox = boxX + (boxW - gridTextWidth) / 2; // Center horizontally in box

                const colWidth =
                    (doc.getStringUnitWidth("W ") * gridFontSize) / scaleFactor;
                const charWidth =
                    (doc.getStringUnitWidth("W") * gridFontSize) / scaleFactor;

                // --- 4. Draw Grid ---
                puzzleGrid.forEach((row, r) => {
                    const yPos = gridTopY_inBox + r * lineH;
                    if (yPos < boxY + boxH) {
                        // Only draw if it fits in the box
                        doc.text(row.join(" "), gridX_inBox, yPos);
                    }
                });

                // --- 5. Draw Strikethroughs ---
                doc.setDrawColor(0, 0, 0); // black line
                doc.setLineWidth(0.3); // 0.3mm thick line

                const yOffset = -(gridFontSize * 0.352778 * 0.3); // Vertical center of line
                const xOffset = charWidth / 2; // Horizontal center of char

                placedWordData.forEach((word) => {
                    // Calculate start (x1, y1) and end (x2, y2) coords
                    const x1 = gridX_inBox + word.c1 * colWidth + xOffset;
                    const y1 = gridTopY_inBox + word.r1 * lineH + yOffset;
                    const x2 = gridX_inBox + word.c2 * colWidth + xOffset;
                    const y2 = gridTopY_inBox + word.r2 * lineH + yOffset;

                    // Only draw line if it's within the box
                    if (y1 < boxY + boxH && y2 < boxY + boxH) {
                        doc.line(x1, y1, x2, y2); // Draw the line
                    }
                });
            }

            /**
             * Compiles all puzzles and solutions into a single PDF
             * @param {object[]} allPuzzles
             */
            async function generatePDF(allPuzzles) {
                // Dynamically get the jsPDF object from the window
                const { jsPDF } = window.jspdf;
                // Default is portrait, 'mm', 'a4'
                const doc = new jsPDF();

                const xMargin = 6.35;
                const yMargin = 6.35;
                const pageW = doc.internal.pageSize.getWidth();
                const pageH = doc.internal.pageSize.getHeight();

                /**
                 * Draws a single page (puzzle or solution)
                 * @param {object} puzzle - The puzzle data
                 * @param {boolean} addPage - Flag to control adding a new page
                 */
                const drawPuzzlePage = (puzzle, addPage = true) => {
                    if (addPage) {
                        doc.addPage();
                    }

                    const { gridSize, wordList, puzzleGrid, originalIndex } =
                        puzzle;

                    // --- 1. Set Margins (0.25 inch) ---
                    const availableWidth = pageW - 2 * xMargin;

                    // --- 2. Draw Title ---
                    const title = `Word Search Puzzle ${originalIndex + 1} (${puzzle.type})`;
                    let titleTopY = yMargin + 10;

                    doc.setFontSize(18);
                    doc.setFont("helvetica", "bold");
                    doc.text(title, pageW / 2, titleTopY, { align: "center" });
                    const gridTopY = titleTopY + 15; // 15mm gap

                    // --- 3. Calculate Dynamic Grid Font Size ---
                    doc.setFont("courier", "normal");
                    const gridString = Array(gridSize).fill("W").join(" ");
                    const scaleFactor = doc.internal.scaleFactor;

                    // Use top 60% of the page for the grid
                    let availableGridHeight = pageH * 0.6 - gridTopY;
                    const fontMaxWidth =
                        (availableWidth * scaleFactor) /
                        doc.getStringUnitWidth(gridString);
                    const lineH_at_1pt = 1 * 0.352778 * 1.1; // 1pt -> mm * 1.1 line spacing
                    const fontMaxHeight =
                        availableGridHeight / (gridSize * lineH_at_1pt);

                    let gridFontSize = Math.min(fontMaxWidth, fontMaxHeight);
                    gridFontSize = Math.max(5, Math.min(16, gridFontSize)); // Clamp font size

                    doc.setFontSize(gridFontSize);

                    // --- 4. Calculate Final Grid Dimensions & Centering ---
                    const lineH = gridFontSize * 0.352778 * 1.1;
                    const gridTextWidth =
                        (doc.getStringUnitWidth(gridString) * gridFontSize) /
                        scaleFactor;
                    const gridX =
                        xMargin + (availableWidth - gridTextWidth) / 2; // Center horizontally

                    // --- 5. Draw Grid ---
                    puzzleGrid.forEach((row, r) => {
                        doc.text(row.join(" "), gridX, gridTopY + r * lineH);
                    });

                    // --- 7. Draw Word List ---
                    doc.setFont("helvetica", "normal");
                    const wordListFontSize = Math.max(8, gridFontSize - 2); // Slightly smaller font
                    doc.setFontSize(wordListFontSize);

                    const wordListLineH = wordListFontSize * 0.352778 * 1.2;
                    const wordListY = pageH * 0.6 + 10;

                    const colCount = 4; // Always use 4 columns for word list
                    const words = wordList; // Already sorted!
                    const rowCountPerCol = Math.ceil(words.length / colCount);
                    const colWidth = availableWidth / colCount;

                    words.forEach((word, i) => {
                        const colIndex = Math.floor(i / rowCountPerCol);
                        const rowIndex = i % rowCountPerCol;

                        const x = xMargin + colIndex * colWidth + colWidth / 2;
                        const y = wordListY + rowIndex * wordListLineH;

                        if (y < pageH - yMargin) {
                            // Check if word list goes off the page
                            doc.text(word, x, y, { align: "center" });
                        }
                    });
                };

                // --- 1. Add all puzzle pages ---
                allPuzzles.forEach((puzzle, index) => {
                    drawPuzzlePage(puzzle, index > 0);
                });

                // --- 2. Add all solution pages ---

                // --- 2a. Process 2x2 Grids (20x20, 30x30) ---
                const puzzles2x2 = allPuzzles.filter(
                    (p) => p.keyLayout === "2x2",
                );
                if (puzzles2x2.length > 0) {
                    doc.addPage();
                    doc.setFontSize(22);
                    doc.setFont("helvetica", "bold");
                    doc.text(
                        "Answer Keys (20x20 & 30x30)",
                        pageW / 2,
                        yMargin + 10,
                        { align: "center" },
                    );

                    const mainTitleH = 20; // 10mm margin + 10mm title
                    const availableW = pageW - 2 * xMargin;
                    const availableH = pageH - yMargin - mainTitleH;
                    const quadW = availableW / 2;
                    const quadH = availableH / 2;
                    const padding = 5; // 5mm padding

                    puzzles2x2.forEach((puzzle, index) => {
                        const gridIndex = index % 4; // 0, 1, 2, or 3
                        if (index > 0 && gridIndex === 0) {
                            doc.addPage();
                        }

                        let quadX, quadY;
                        if (gridIndex === 0) {
                            quadX = xMargin;
                            quadY = yMargin + mainTitleH;
                        } // Top-left
                        else if (gridIndex === 1) {
                            quadX = xMargin + quadW;
                            quadY = yMargin + mainTitleH;
                        } // Top-right
                        else if (gridIndex === 2) {
                            quadX = xMargin;
                            quadY = yMargin + mainTitleH + quadH;
                        } // Bottom-left
                        else {
                            quadX = xMargin + quadW;
                            quadY = yMargin + mainTitleH + quadH;
                        } // Bottom-right

                        const boxX = quadX + padding;
                        const boxY = quadY + padding;
                        const boxW = quadW - 2 * padding;
                        const boxH = quadH - 2 * padding;
                        const title = `Puzzle ${puzzle.originalIndex + 1} (${puzzle.type})`;

                        drawAnswerGrid(
                            doc,
                            puzzle,
                            boxX,
                            boxY,
                            boxW,
                            boxH,
                            title,
                        );
                    });
                }

                // --- 2b. Process 1x2 Grids (40x40) ---
                const puzzles1x2 = allPuzzles.filter(
                    (p) => p.keyLayout === "1x2",
                );
                if (puzzles1x2.length > 0) {
                    doc.addPage();
                    doc.setFontSize(22);
                    doc.setFont("helvetica", "bold");
                    doc.text("Answer Keys (40x40)", pageW / 2, yMargin + 10, {
                        align: "center",
                    });

                    const mainTitleH = 20;
                    const availableW = pageW - 2 * xMargin;
                    const availableH = pageH - yMargin - mainTitleH;
                    const quadW = availableW; // Full width
                    const quadH = availableH / 2; // Half height
                    const padding = 5;

                    puzzles1x2.forEach((puzzle, index) => {
                        const gridIndex = index % 2; // 0 or 1
                        if (index > 0 && gridIndex === 0) {
                            doc.addPage();
                        }

                        let quadX = xMargin;
                        let quadY =
                            gridIndex === 0
                                ? yMargin + mainTitleH // Top
                                : yMargin + mainTitleH + quadH; // Bottom

                        const boxX = quadX + padding;
                        const boxY = quadY + padding;
                        const boxW = quadW - 2 * padding;
                        const boxH = quadH - 2 * padding;
                        const title = `Puzzle ${puzzle.originalIndex + 1} (${puzzle.type})`;

                        drawAnswerGrid(
                            doc,
                            puzzle,
                            boxX,
                            boxY,
                            boxW,
                            boxH,
                            title,
                        );
                    });
                }

                // --- 3. Save the PDF ---
                doc.save("Word-Search-Puzzles.pdf");
            }

            /**
             * Sets the loading state of the UI
             * @param {boolean} isLoading
             */
            function setLoadingState(isLoading) {
                generateBtn.disabled = isLoading;
                [count20x20, count30x30, count40x40].forEach((input) => {
                    input.disabled = isLoading;
                });

                if (isLoading) {
                    generateBtn.textContent = "Generating...";
                } else {
                    generateBtn.textContent = "Generate PDF";
                    updateCounter(); // Re-check button state
                }
            }

            /**
             * Updates the status message
             * @param {string} message
             * @param {'loading' | 'error' | 'success' | 'normal'} type
             */
            function setStatus(message, type = "normal") {
                statusEl.textContent = message;
                statusEl.classList.remove(
                    "text-gray-500",
                    "text-red-600",
                    "text-green-600",
                );

                switch (type) {
                    case "error":
                        statusEl.classList.add("text-red-600");
                        break;
                    case "success":
                        statusEl.classList.add("text-green-600");
                        break;
                    case "loading":
                    case "normal":
                    default:
                        statusEl.classList.add("text-gray-500");
                        break;
                }
            }
        </script>
    </body>
</html>
